#!/usr/bin/env python3

from optparse import OptionParser
from lxml import etree
import requests
import os
import pprint
import time
import importlib
import importlib.machinery
from urllib.parse import urlparse, urlunparse, urlencode, parse_qsl

try:
    from pygments import highlight
    from pygments.lexers import get_lexer_by_name
    from pygments.formatters import TerminalFormatter, HtmlFormatter
except ImportError:
    _have_pygment = False
else:
    _have_pygment = True

BOLD = "\033[1m"
DIM = "\033[2m"
UNDERLINE = "\033[4m"
BLINK = "\033[5m"
NORMAL = "\033[0;0m"
RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
BLUE = "\033[34m"
DEFAULT = "\033[39m"
WHITE = "\033[37m"
BACK_BLUE = "\033[44m"
BACK_DEFAULT = "\033[49m"


# Options
parser = OptionParser(usage="restnote [options] file")
parser.add_option(
    '-f', '--format', dest='output_format', default='terminal',
    help='output format to use (terminal or html)')


options, args = parser.parse_args()
input_filename = args.pop(0)
pp = pprint.PrettyPrinter(indent=2)


class Terminal:
    def __init__(self):
        self.mute = False
        self.smute = []
        self.graphical = False
        if _have_pygment:
            self.formatter = TerminalFormatter()
            self.lexer = get_lexer_by_name('xml')

    def log(self, desc, data=None, data_type=None):
        if self.mute or data_type in self.smute:
            return
        if data_type == 'comment':
            print(BLUE + desc.strip() + NORMAL)
            return
        if data_type == 'title':
            print(BOLD + BLUE + desc.strip() + NORMAL)
            return
        if data_type == 'table':
            lengths = [len(x) for x in desc]
            for row in data:
                lengths = [max(lengths[n], len(x)) for n, x in enumerate(row)]
            fs = '  '.join([('%%-%is' % l) for l in lengths])
            print(fs % desc)
            for row in data:
                print(fs % row)
            return
        if data_type == 'error':
            print(BOLD + RED + desc + NORMAL)
        elif data_type == 'ok':
            print(BOLD + GREEN + desc + NORMAL)
        elif desc is not None:
            print("%s%s%s" % (BOLD, desc, NORMAL))
        if data is not None:
            if _have_pygment and data_type == 'xml':
                try:
                    data = etree.tostring(data)
                except AttributeError:
                    pass
                except TypeError:
                    pass
                try:
                    data = data.decode()
                except AttributeError:
                    data = str(data)
                print(highlight(data, self.lexer, self.formatter))
            elif data_type in ('pp', 'error'):
                pp.pprint(data)
            else:
                print(data)

    def close(self):
        pass


class HTML:
    def __init__(self):
        self.mute = False
        self.smute = []
        self.graphical = True
        if _have_pygment:
            self.formatter = HtmlFormatter()
            self.lexer = get_lexer_by_name('xml')
        print("<html><head><style>\n")
        print(self.formatter.get_style_defs())
        print(".header { font-family: arial; font-weight: bold }")
        print(""".code { background-color: #fafafa; border-left: 2px solid #aaa;
                  padding: 5px; margin-top: 5px; margin-bottom: 5px } """)
        print(""".comment { font-family: arial; font-weight:
                  normal; color: blue; margin-bottom: 20px;
                  font-style: italic; margin-top: 20px}""")
        print(""".title { font-family: arial; font-size: 24; font-weight:
                  bold; color: blue; margin-bottom: 20px;
                  margin-top: 20px}""")
        print(""".error { font-family: arial; font-size: 12; font-weight:
                  bold; color: red; margin-bottom: 20px;
                  margin-top: 20px}""")
        print(""".error { font-family: arial; font-size: 12; font-weight:
                  bold; color: green; margin-bottom: 20px;
                  margin-top: 20px}""")
        print(""" table { font-family: arial; font-size: 12; font-weight:
                  normal; margin-bottom: 20px;
                  margin-top: 20px}""")
        print(""" th { font-family: arial; font-size: 12; font-weight:
                  bold; text-align: left }""")
        print(""" td { border-top: 1px solid #ccc }""")
        print("</style></head><body>")
        self.counter = 0

    def get_id(self):
        self.counter += 1
        return "obj%i" % self.counter

    def log(self, desc, data=None, data_type=None):
        if self.mute or data_type in self.smute:
            return
        if data_type == 'comment':
            print("<div class=\"comment\">%s</div>" % desc)
            return
        if data_type == 'title':
            print("<div class=\"title\">%s</div>" % desc)
            return
        if data_type == 'table':
            print("<table><tr>")
            for heading in desc:
                print('<th>%s</th>' % heading)
            print("</tr>")
            for row in data:
                print("<tr>")
                for col in row:
                    print('<td>%s</td>' % col)
                print("</tr>")
            print("</table>")
            return
        if data_type == 'error':
            print("<div class=\"error\">%s</div>" % desc)
        elif data_type == 'ok':
            print("<div class=\"ok\">%s</div>" % desc)
        elif desc is not None:
            print("<div class=\"header\">%s</div>" % desc)
        if data is not None:
            print("<div class=\"code\">")
            if _have_pygment and data_type == 'xml':
                try:
                    data = etree.tostring(data)
                except AttributeError:
                    pass
                except TypeError:
                    pass
                try:
                    data = data.decode()
                except AttributeError:
                    data = str(data)
                print(highlight(str(data), self.lexer, self.formatter))
            elif data_type == 'pp':
                print("<pre>")
                pp.pprint(data)
                print("</pre>")
            else:
                data = (str(data).replace('&', '&amp;').replace('<', '&lt;')
                        .replace('>', '&gt'))
                print("<pre>%s</pre>" % data)
            print("</div>")

    def close(self):
        print("</body></html>\n")

basevar = {'true': True, 'false': False, 'none': None}


class Environment:
    def __init__(self, logger):
        self.var = dict(basevar)
        self.attached = {}
        self.logger = logger
        self.namespaces = {}
        self.session = None
        self.terminate = False

    def __repr__(self):
        return '<Environment %s>' % self.filename

    def log(self, *args):
        if self.logger is not None:
            self.logger.log(*args)

    @property
    def line_iterator(self):
        if self.read_mode == 'file':
            with open(self.filename, 'r') as IF:
                for line in IF:
                    yield line
        elif self.read_mode == 'local':
            for line in self.lines:
                yield line

    def copy(self):
        c = Environment(self.logger)
        c.var = {}
        c.var.update(self.var)
        c.session = self.session
        c.namespaces = self.namespaces
        c.lines = self.lines
        c.filename = self.filename
        c.read_mode = self.read_mode
        c.attached = self.attached
        if hasattr(self, 'args'):
            c.args = self.args
        return c

    def substitute(self, single, *args):
        sargs = []
        keys = [k for k in self.var.keys()
                if not k.startswith('_')]
        for arg in args:
            for key in keys:
                if arg == '(%s)' % key:
                    arg = self.var[key]
                    break
            for key in keys:
                try:
                    arg = arg.replace('(%s)' % key,
                                      str(self.var[key]))
                except TypeError:
                    break
                except AttributeError:
                    break
            sargs.append(arg)
        if single:
            return sargs[0]
        else:
            return sargs

    def load(self, filename):
        self.read_mode = 'file'
        self.filename = filename

    def local(self, name, lines):
        self.read_mode = 'local'
        self.lines = lines
        self.filename = name

    def run(self):
        self.mode = 'normal'
        self.data = None
        for line in self.line_iterator:
            if self.terminate:
                break
            if self.mode == 'until':
                if line.startswith(self.data_terminator):
                    self.mode = 'normal'
                    line = line.replace(self.data_terminator, 'then')
                else:
                    self.data += line
                    continue

            if self.mode == 'block':
                if line.startswith(self.data_terminator):
                    self.mode = 'normal'
                else:
                    self.data.append(line.strip())

            if self.mode == 'normal':
                line = line.rstrip()
                if line.startswith('%%'):
                    self.log(line[2:], None, 'title')
                    continue
                if line.startswith('%'):
                    self.log(line[1:], None, 'comment')
                    continue
                if line == '':
                    continue
                parts = line.split(' -> ')
                self.must = False
                if len(parts) == 1:
                    self.command = line
                    self.target = None
                else:
                    self.command = parts[0].strip()
                    self.target = parts[1].strip()
                    if self.target.endswith('!'):
                        self.must = True
                        self.target = self.target[:-1]

                if self.command.startswith('until '):
                    self.data_terminator = self.command[6:].strip()
                    self.mode = 'until'
                    self.data = ''
                    continue

                if self.command.startswith('while '):
                    self.data_terminator = 'endwhile'
                    self.mode = 'block'
                    self.data = []
                    self.block_expression = self.command[6:].strip()
                    continue

                if self.command.startswith('if '):
                    self.data_terminator = 'endif'
                    self.mode = 'block'
                    self.data = []
                    self.block_expression = self.command[3:].strip()
                    continue

                if self.command == 'sub':
                    self.data_terminator = 'endsub'
                    self.mode = 'block'
                    self.data = []
                    self.block_expression = self.command[4:].strip()
                    continue

                elif self.command == 'then':
                    if self.target is not None:
                        self.var[self.target] = self.data
                else:
                    parts = self.command.split(' ', 1)
                    command = parts.pop(0)
                    if len(parts) > 0:
                        argstring = parts.pop()
                        argstring = argstring.replace('\,', '{{COMMA}}')
                        args = [a.strip().replace('{{COMMA}}', ',')
                                for a in argstring.split(',')]
                    else:
                        args = []
                    args = self.substitute(False, *args)

                    if command == 'connect':
                        result = self.connect(*args)
                    elif command == 'include':
                        result = self.include(*args)
                    elif command == 'env':
                        result = self.env(*args)
                    elif command == 'get':
                        result = self.get(*args)
                    elif command == 'put':
                        result = self.put(*args)
                    elif command == 'post':
                        result = self.post(*args)
                    elif command == 'delete':
                        result = self.delete(*args)
                    elif command == 'xml':
                        result = self.xml(*args)
                    elif command == 'xmod':
                        result = self.xmod(*args)
                    elif command == 'xattr':
                        result = self.xattr(*args)
                    elif command == 'xadd':
                        result = self.xadd(*args)
                    elif command == 'xdelete':
                        result = self.xdelete(*args)
                    elif command == 'raw':
                        result = self.raw(*args)
                    elif command == 'headers':
                        result = self.headers(*args)
                    elif command == 'xpath':
                        result = self.xpath(*args)
                    elif command == 'fopen':
                        result = self.fopen(*args)
                    elif command == 'fclose':
                        result = self.fclose(*args)
                    elif command == 'dict':
                        result = self.dict(*args)
                    elif command == 'argdict':
                        result = self.argdict(*args)
                    elif command == 'argpop':
                        result = self.argpop(*args)
                    elif command == 'template':
                        result = self.template(*args)
                    elif command == 'sleep':
                        result = self.sleep(*args)
                    elif command == 'log':
                        result = self.log(*args)
                    elif command == 'eval':
                        result = self.eval(*args)
                    elif command == 'fill':
                        result = self.substitute(True, *args)
                    elif command == 'value':
                        result = self.value(*args)
                    elif command == 'each':
                        result = self.each(*args)
                    elif command == 'append':
                        result = self.append(*args)
                    elif command == 'urilist':
                        result = self.urilist(*args)
                    elif command == 'list':
                        result = self.makelist(*args)
                    elif command == 'namespace':
                        result = self.namespace(*args)

                    elif command == 'endwhile':
                        result = self.endwhile(*args)
                    elif command == 'endif':
                        result = self.endif(*args)
                    elif command == 'endsub':
                        result = self.endsub(self.target, *args)
                    elif command == 'call':
                        result = self.callsub(*args)
                    elif command == 'return':
                        result = self.returnsub(*args)

                    elif command == 'external':
                        result = self.newclass(*args)
                    elif command == 'internal':
                        result = self.newlocalclass(*args)
                    elif command == 'use':
                        result = self.useclass(*args)
                    elif command == 'debug':
                        result = self.debug(*args)
                    elif command == 'every':
                        result = self.every(*args)
                    elif command == 'idle':
                        result = self.every()
                    elif command == 'attach':
                        result = self.attach(*args)
                    elif command == 'setlog':
                        result = self.setlog(*args)
                    elif command == 'is':
                        result = self.i_am(*args)
                    else:
                        raise ValueError("Unknown command '%s'" % command)

                    if self.target is not None:
                        self.var[self.target] = result
                        if self.must and result in (None, False, []):
                            self.log(
                                "Exiting block, missing required data",
                                {'command': command,
                                 'args': args,
                                 'result': result}, 'error')
                            self.return_value = False
                            self.terminate = True

    def connect(self, host, user, password):
        self.session = requests.Session()
        self.session.auth = (user, password)
        self.headers = {}
        self.log("System", "host=%s, user=%s" % (host, user))

    def env(self, name, default=''):
        return os.getenv(name, default)

    def include(self, filename, args=''):
        self.log("Include", filename)
        if not filename.endswith('.rest'):
            filename = filename + '.rest'
        if filename == self.filename:
            raise ValueError("Can't include self!")
        subenv = Environment(self.logger if 'log' in args else None)
        subenv.session = self.session
        subenv.namespaces = self.namespaces
        subenv.load(filename)
        subenv.run()
        self.var.update(subenv.var)
        self.session = subenv.session
        self.namespaces = subenv.namespaces

    def xml(self, response):
        try:
            return etree.fromstring(response.content)
        except AttributeError:
            return etree.fromstring(response.encode())

    def xmod(self, dom, xpath, new_value):
        if xpath == '.':
            element = dom
        else:
            element = self.xpath(dom, xpath)
        if element is not None:
            element.text = new_value
            self.log("New value", new_value, 'pp')

    def xattr(self, dom, xpath, attr, new_value):
        element = self.xpath(dom, xpath)
        if element is not None:
            element.set(attr, new_value)
            self.log("New attribute value", '%s = "%s"' %
                     (attr, new_value), 'pp')

    def xadd(self, dom, xpath, tag):
        element = self.xpath(dom, xpath)
        if element is not None:
            prefix, name = tag.split(':', 1)
            return etree.SubElement(
                element,
                '{%s}%s' % (self.namespaces.get(prefix), name))

    def raw(self, response):
        return response.content.decode()

    def xpath(self, dom, xpath, want1=True):
        if not hasattr(dom, 'xpath'):
            raise TypeError('%s is not an XML element' % str(dom))
        result = dom.xpath(xpath, namespaces=self.namespaces)
        if want1:
            try:
                result = result[0]
            except IndexError:
                if not result:
                    result = None
        self.log("Resolve xpath", (xpath, result), 'pp')
        return result

    def get(self, url, accept=None, headers={}):
        if accept is not None:
            headers = dict(headers)
            headers['accept'] = accept
        self.log("GET >>> " + str(url), headers, 'pp')
        response = self.session.get(url, headers=headers)
        self.log("GET <<< [%s]" % response.status_code,
                 dict(response.headers), 'pp')
        self.log(
            None,
            response.content.decode(),
            'xml' if 'xml' in response.headers.get('content-type', '')
            else None)
        return response

    def put(self, url, data, content_type, headers={}):
        headers = dict(headers)
        headers['content-type'] = content_type
        self.log("PUT >>> " + str(url), headers, 'pp')
        try:
            data = etree.tostring(data)
        except AttributeError:
            pass
        except TypeError:
            pass
        self.log(None, data, 'xml')
        response = self.session.put(url, data=data, headers=headers)
        self.log("PUT <<< [%s]" % response.status_code,
                 dict(response.headers), 'pp')
        self.log(
            None,
            response.content.decode(),
            'xml' if 'xml' in response.headers.get('content-type', '')
            else None)
        return response

    def post(self, url, data, content_type, headers={}):
        headers = dict(headers)
        headers['content-type'] = content_type
        self.log("POST >>> " + str(url), headers, 'pp')
        try:
            data = etree.tostring(data)
        except AttributeError:
            pass
        except TypeError:
            pass
        self.log(None, data, 'xml')
        response = self.session.post(url, data=data, headers=headers)
        self.log("POST <<< [%s]" % response.status_code,
                 dict(response.headers), 'pp')
        self.log(
            None,
            response.content.decode(),
            'xml' if 'xml' in response.headers.get('content-type', '')
            else None)
        return response

    def delete(self, url, headers={}):
        headers = dict(headers)
        self.log("DELETE >>> " + url, headers, 'pp')
        response = self.session.delete(url, headers=headers)
        self.log("DELETE <<< [%s]" % response.status_code,
                 dict(response.headers), 'pp')
        self.log(
            None,
            response.content.decode(),
            'xml' if 'xml' in response.headers.get('content-type', '')
            else None)
        return response

    def fopen(self, filename, mode='r'):
        self.log("Open file", filename)
        return open(filename, mode)

    def fclose(self, f):
        f.close()

    def dict(self, *pairs):
        d = {}
        for key, value in [p.split('=') for p in pairs]:
            d[key] = self.substitute(True, value)
        return d

    def argdict(self):
        d = {}
        for key, value in [p.split('=') for p in self.sysargs]:
            d[key] = self.substitute(True, value)
        return d

    def argpop(self):
        return self.sysargs.pop(0)

    def template(self, template, subs):
        self.log('substituting', subs, 'pp')
        scheme, netloc, path, params, query, fragment = urlparse(template)
        qparams = parse_qsl(query)
        new_qparams = []
        for k, v in qparams:
            if v.startswith('{'):
                name = v.replace('{', '').replace('}', '').replace('?', '')
                if name in subs:
                    new_qparams.append((k, subs[name]))
            else:
                new_qparams.append((k, v))
        url = urlunparse((scheme, netloc, path, params,
                          urlencode(new_qparams), fragment))
        self.log('resulting url', url)
        return url

    def sleep(self, t):
        time.sleep(float(t))

    def endwhile(self):
        subenv = Environment(self.logger)
        subenv.local(self.block_expression, self.data)
        subenv.var.update(
            {k: v for k, v in self.var.items() if not k.startswith('_')})
        subenv.session = self.session
        subenv.namespaces = self.namespaces
        subenv.return_value = None
        counter = 0
        while eval(self.block_expression, subenv.var):
            subenv.run()
            counter += 1
        self.var.update(
            {k: v for k, v in subenv.var.items()
             if not k.startswith('_') and k in self.var})
        self.return_value = subenv.return_value
        return counter

    def endif(self):
        subenv = Environment(self.logger)
        subenv.local(self.block_expression, self.data)
        subenv.var = self.var
        subenv.session = self.session
        subenv.namespaces = self.namespaces
        if eval(self.block_expression, self.var):
            subenv.run()
            self.terminate = subenv.terminate
            return True
        else:
            return False

    def endsub(self, target, *args):
        subenv = Environment(self.logger)
        subenv.local(self.target, self.data)
        subenv.args = args
        subenv.namespaces = self.namespaces
        subenv.session = self.session
        subenv.name = target
        return subenv

    def callsub(self, subenv, *args):
        if not hasattr(subenv, 'copy') or not hasattr(subenv, 'args'):
            raise TypeError("%s is not a sub routine" % str(subenv))
        subenv = subenv.copy()
        argd = {}
        for i, arg in enumerate(subenv.args):
            try:
                value = args[i]
            except IndexError:
                raise TypeError("Missing argument '%s' % arg")
            argd[arg] = value
        subenv.var = dict(basevar)
        subenv.var.update(subenv.attached)
        subenv.var.update(argd)
        subenv.return_value = None
        subenv.run()
        return subenv.return_value

    def returnsub(self, value=None):
        self.terminate = True
        self.return_value = value
        return value

    def eval(self, expression):
        return eval(expression, self.var)

    def value(self, expression):
        return self.substitute(True, expression)

    def each(self, data, subenv, *args):
        returns = []
        for entry in data:
            returns.append(self.callsub(subenv, entry, *args))
        return returns

    def append(self, l, entry):
        l.append(entry)
        return len(l)

    def urilist(self, uris):
        return '\n'.join(uris)

    def makelist(self, *items):
        return items

    def namespace(self, short, uri):
        self.namespaces[short] = uri

    def newclass(self, module_name, class_name, *args):
        module = importlib.import_module(module_name)
        Class = getattr(module, class_name)
        self.log("Constructing local %s" % (Class),
                 args, 'pp')
        return Class(*args)

    def newlocalclass(self, path, module_name, class_name, *args):
        loader = importlib.machinery.SourceFileLoader(
            module_name, path)
        module = loader.load_module()
        Class = getattr(module, class_name)
        return Class(*args)

    def useclass(self, inst, method, *args):
        self.log("Calling method %s on %s" %
                 (method, inst),
                 args, 'pp')
        return getattr(inst, method)(*args)

    def debug(self):
        self.log("Debug", {k: v for k, v in self.var.items()
                           if not k.startswith('__')}, 'pp')

    def every(self, interval=10, handler=None, *args):
        while True:
            self.sleep(interval)
            if handler is not None:
                self.callsub(handler, *args)

    def attach(self, sub, on):
        self.log("Attaching", sub.name + " on " + on.name)
        on.attached[sub.name] = sub

    def setlog(self, *args):
        if self.logger is None:
            return
        for arg in args:
            if arg == 'mute':
                self.logger.mute = True
            elif arg == 'unmute':
                self.logger.mute = False
            elif arg.startswith('+'):
                arg = arg[1:]
                if arg in self.logger.smute:
                    self.logger.smute.remove(arg)
            elif arg.startswith('-'):
                arg = arg[1:]
                if arg not in self.logger.smute:
                    self.logger.smute.append(arg)

    def i_am(self, what):
        if what == 'graphical':
            if self.logger is not None:
                return self.logger.graphical
        return False

if options.output_format == 'terminal':
    logger = Terminal()
elif options.output_format == 'html':
    logger = HTML()
else:
    logger = None

environment = Environment(logger)
environment.sysargs = args
environment.load(input_filename)
try:
    environment.run()
finally:
    if logger is not None:
        logger.close()
